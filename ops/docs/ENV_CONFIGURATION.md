# Environment Configuration Guide

## Overview

The Computor platform uses a **single unified configuration file** (`.env.common`) that contains ALL settings for the platform, including optional Coder integration.

## File Structure

```
computor-fullstack/
├── .env.common         # Main configuration (ALL variables)
├── .env                # Working copy (duplicate of .env.common)
├── .env.dev            # Development overrides (small, only host changes)
├── .env.prod           # Production overrides (small, only host changes)
└── ops/environments/
    └── .env.common.template  # Template with all variables
```

## Quick Setup

### First Time Setup
```bash
# Interactive setup (recommended)
./setup-env.sh

# Or automatic with defaults
./setup-env.sh --auto
```

This will:
1. Create `.env.common` with all configuration
2. Generate secure passwords and tokens
3. Configure Coder if requested
4. Create `.env` as a working copy
5. Create `.env.dev` and `.env.prod` with minimal overrides

### Using Existing Configuration
```bash
# Keep your existing .env, only update .env.common
./setup-env.sh --preserve

# Force recreate everything
./setup-env.sh --force
```

## Configuration Files Explained

### `.env.common` - Main Configuration
- **Contains**: ALL environment variables for the entire platform
- **Includes**: Backend, database, Redis, Temporal, MinIO, Coder, workers, etc.
- **Generated from**: `ops/environments/.env.common.template`
- **When to edit**: To change any configuration value

### `.env` - Working Copy
- **Contains**: Copy of `.env.common` for backward compatibility
- **Purpose**: Some tools expect `.env` in the root
- **Auto-created**: By setup-env.sh

### `.env.dev` - Development Overrides
- **Contains**: Only host/port overrides for local development
- **Example**: `POSTGRES_HOST=localhost` instead of `postgres`
- **Size**: ~6 lines

### `.env.prod` - Production Overrides
- **Contains**: Only host/port overrides for production
- **Example**: `POSTGRES_HOST=postgres`, restricted MinIO ports
- **Size**: ~6 lines

## Key Variables

### Core Services
```bash
# Database
POSTGRES_USER=postgres
POSTGRES_PASSWORD=<auto-generated>
POSTGRES_DB=computor

# Redis
REDIS_PASSWORD=<auto-generated>

# API
API_ADMIN_USER=admin
API_ADMIN_PASSWORD=<auto-generated>

# Security
TOKEN_SECRET=<auto-generated>
AUTH_SECRET=<auto-generated>
```

### Coder Integration (Optional)
```bash
# Enable/disable Coder
CODER_ENABLED=false  # Set to true to enable

# Coder configuration
CODER_DOMAIN=coder.localhost
CODER_ADMIN_EMAIL=admin@example.com
CODER_ADMIN_PASSWORD=<auto-generated>
CODER_ADMIN_API_SECRET=<auto-generated>

# Coder uses the main PostgreSQL
CODER_POSTGRES_USER=${POSTGRES_USER}
CODER_POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
```

## How It Works

### Loading Order
1. `startup.sh` loads `.env.common` (or `.env` if .env.common doesn't exist)
2. Then loads `.env.dev` or `.env.prod` to override specific values
3. Docker Compose uses the combined environment

### Environment Overrides
Development (`./startup.sh dev`):
- Uses localhost for database connections
- Single worker replicas
- Debug mode enabled

Production (`./startup.sh prod`):
- Uses Docker service names for connections
- Multiple worker replicas
- Debug mode disabled
- Restricted ports

## Enabling Coder

### During Setup
```bash
./setup-env.sh
# Choose "y" when asked about Coder
```

### Manually
Edit `.env.common`:
```bash
CODER_ENABLED=true
CODER_DOMAIN=your-coder-domain.com
CODER_ADMIN_EMAIL=admin@yourdomain.com
```

Then start with:
```bash
./startup.sh dev -d
```

## Migration from Old Structure

If you have old separate `.env` files:

1. **Backup everything**:
   ```bash
   cp .env .env.backup
   cp .env.dev .env.dev.backup
   cp .env.prod .env.prod.backup
   ```

2. **Run setup**:
   ```bash
   ./setup-env.sh
   ```

3. **Merge custom values**:
   - Open `.env.backup` and `.env.common` side by side
   - Copy any custom values to `.env.common`
   - All variables are now in one place

## Security Notes

1. **Never commit** `.env*` files to git (already in .gitignore)
2. **Secure passwords** are auto-generated
3. **Backup files** are created with timestamps
4. **Coder credentials** are generated if not provided

## Troubleshooting

### Missing Variables
If a service complains about missing variables:
1. Check if the variable is in `.env.common`
2. Check if it's being overridden in `.env.dev` or `.env.prod`
3. Re-run `./setup-env.sh` to ensure all variables are present

### Coder Not Working
1. Check `CODER_ENABLED=true` in `.env.common`
2. Verify PostgreSQL is running: `docker ps | grep postgres`
3. Check Coder database exists: The startup script automatically creates it when `CODER_ENABLED=true`

### Environment Confusion
To see which environment variables are loaded:
```bash
# Check what's in the environment
docker-compose -f ops/docker/docker-compose.base.yaml config
```

## Best Practices

1. **Use `.env.common` for everything** - It's the single source of truth
2. **Keep overrides minimal** - Only put host/port changes in `.env.dev` and `.env.prod`
3. **Don't duplicate variables** - If it's the same in dev and prod, put it in `.env.common`
4. **Use setup script** - It handles token generation and proper configuration
5. **Backup before changes** - The script auto-backs up, but manual backups are good too