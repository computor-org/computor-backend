"""Parser for Excel-compatible XML format (SpreadsheetML)."""
import xml.etree.ElementTree as ET
from typing import List, Dict, Optional
import logging

logger = logging.getLogger(__name__)


class ExcelXMLParser:
    """Parser for Microsoft Excel XML format (SpreadsheetML).

    This format is generated by Excel when saving as "XML Spreadsheet 2003 (*.xml)"
    and is commonly used for data exports from university systems.
    """

    # XML namespaces used in Excel XML format
    NAMESPACES = {
        'ss': 'urn:schemas-microsoft-com:office:spreadsheet',
        'wb': 'urn:schemas-microsoft-com:office:excel',
    }

    def __init__(self, xml_content: str):
        """Initialize parser with XML content.

        Args:
            xml_content: Raw XML string content
        """
        self.xml_content = xml_content
        self.root = None
        self.headers = []
        self.rows = []

    def parse(self) -> List[Dict[str, str]]:
        """Parse XML content and return list of dictionaries.

        Returns:
            List of dictionaries where keys are column headers and values are cell values

        Raises:
            ValueError: If XML is malformed or doesn't match expected structure
        """
        try:
            self.root = ET.fromstring(self.xml_content)
        except ET.ParseError as e:
            raise ValueError(f"Invalid XML format: {e}")

        # Find the worksheet
        worksheet = self.root.find('.//ss:Worksheet', self.NAMESPACES)
        if worksheet is None:
            raise ValueError("No worksheet found in XML")

        # Find the table
        table = worksheet.find('ss:Table', self.NAMESPACES)
        if table is None:
            raise ValueError("No table found in worksheet")

        # Extract rows
        rows = table.findall('ss:Row', self.NAMESPACES)
        if not rows:
            raise ValueError("No rows found in table")

        # First row is assumed to be headers
        header_row = rows[0]
        self.headers = self._extract_row_data(header_row)

        if not self.headers:
            raise ValueError("No headers found in first row")

        logger.info(f"Found {len(self.headers)} columns: {self.headers}")

        # Process data rows
        result = []
        for row_idx, row in enumerate(rows[1:], start=2):  # Start from 2 (1 is header)
            row_data = self._extract_row_data(row)

            # Skip empty rows
            if not any(row_data):
                continue

            # Create dictionary mapping headers to values
            row_dict = {}
            for col_idx, header in enumerate(self.headers):
                value = row_data[col_idx] if col_idx < len(row_data) else ""
                row_dict[header] = value.strip() if value else ""

            result.append(row_dict)

        logger.info(f"Parsed {len(result)} data rows")
        return result

    def _extract_row_data(self, row_element) -> List[str]:
        """Extract cell data from a row element.

        Args:
            row_element: XML element representing a row

        Returns:
            List of cell values as strings
        """
        cells = row_element.findall('ss:Cell', self.NAMESPACES)
        row_data = []
        current_index = 0

        for cell in cells:
            # Check if cell has an Index attribute (indicates skipped columns)
            index_attr = cell.get(f"{{{self.NAMESPACES['ss']}}}Index")
            if index_attr:
                target_index = int(index_attr) - 1  # Convert to 0-based
                # Fill skipped columns with empty strings
                while current_index < target_index:
                    row_data.append("")
                    current_index += 1

            # Extract cell value
            data_element = cell.find('ss:Data', self.NAMESPACES)
            if data_element is not None and data_element.text:
                row_data.append(data_element.text)
            else:
                row_data.append("")

            current_index += 1

        return row_data

    @staticmethod
    def parse_from_file(file_path: str) -> List[Dict[str, str]]:
        """Parse Excel XML from a file.

        Args:
            file_path: Path to XML file

        Returns:
            List of dictionaries representing rows
        """
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        parser = ExcelXMLParser(content)
        return parser.parse()

    @staticmethod
    def parse_from_bytes(content: bytes) -> List[Dict[str, str]]:
        """Parse Excel XML from bytes.

        Args:
            content: XML content as bytes

        Returns:
            List of dictionaries representing rows
        """
        # Try different encodings
        for encoding in ['utf-8', 'utf-8-sig', 'latin-1', 'cp1252']:
            try:
                xml_string = content.decode(encoding)
                parser = ExcelXMLParser(xml_string)
                return parser.parse()
            except (UnicodeDecodeError, ValueError) as e:
                logger.debug(f"Failed to parse with {encoding}: {e}")
                continue

        raise ValueError("Could not decode XML file with any common encoding")


def parse_course_member_xml(xml_content: str | bytes) -> List[Dict[str, str]]:
    """Convenience function to parse course member XML.

    Args:
        xml_content: XML content as string or bytes

    Returns:
        List of dictionaries with standardized keys
    """
    if isinstance(xml_content, bytes):
        rows = ExcelXMLParser.parse_from_bytes(xml_content)
    else:
        parser = ExcelXMLParser(xml_content)
        rows = parser.parse()

    # Standardize common German column names to English keys
    column_mapping = {
        'E-Mail': 'email',
        'Familienname': 'family_name',
        'Vorname': 'given_name',
        'Matrikelnummer': 'student_id',
        'Gruppe': 'course_group_title',
        'Incoming': 'incoming',
        'Kennzahl': 'study_id',
        'Studien-ID': 'study_id',
        'Studium': 'study_name',
        'Semester im Studium': 'semester',
        'Anmeldedatum': 'registration_date',
        'Anmerkung': 'notes',
        'lfd.Nr.': 'sequence_number',
        'Platz': 'place',
        'Wartelistenposition': 'waitlist_position',
    }

    # Transform rows to use standardized keys
    standardized_rows = []
    for row in rows:
        standardized = {}
        for original_key, value in row.items():
            # Use mapped key if available, otherwise use original
            key = column_mapping.get(original_key, original_key.lower().replace(' ', '_'))
            standardized[key] = value
        standardized_rows.append(standardized)

    return standardized_rows
