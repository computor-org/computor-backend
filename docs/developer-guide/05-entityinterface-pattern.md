# EntityInterface Pattern

The EntityInterface pattern is the core design pattern in Computor that drives code generation, API structure, and type safety across the entire stack.

## What is EntityInterface?

`EntityInterface` is an abstract base class defined in `computor-types` that serves as a **single source of truth** for entity DTOs (Data Transfer Objects).

```python
# computor-types/src/computor_types/base.py
from abc import ABC
from pydantic import BaseModel

class EntityInterface(ABC):
    """Pure DTO interface - defines data structure only."""
    create: BaseModel = None
    get: BaseModel = None
    list: BaseModel = None
    update: BaseModel = None
    query: BaseModel = None
```

Each entity in the system has an Interface class that defines its CRUD DTOs.

## Why EntityInterface?

### Problems It Solves

1. **Duplication**: Without EntityInterface, you'd define DTOs in multiple places
2. **Inconsistency**: Different endpoints might use different field names/types
3. **Manual Client Generation**: Building HTTP clients would require manual coding
4. **Type Safety**: No automatic TypeScript types for frontend

### Benefits

- **Single Source of Truth**: One place defines all DTOs for an entity
- **Auto-Generation**: Python client, TypeScript types, and API docs generated automatically
- **Type Safety**: End-to-end type safety from database to frontend
- **Consistency**: All endpoints follow the same patterns
- **Discoverability**: `get_all_dtos()` function finds all entities

## Basic Example

### Define an EntityInterface

```python
# computor-types/src/computor_types/users.py
from typing import Optional
from pydantic import BaseModel, EmailStr
from computor_types.base import EntityInterface, BaseEntityGet, BaseEntityList

class UserInterface(EntityInterface):
    """User entity interface."""
    create = "UserCreate"      # Reference to create DTO
    get = "UserGet"            # Reference to get DTO
    list = "UserList"          # Reference to list DTO
    update = "UserUpdate"      # Reference to update DTO
    query = "UserQuery"        # Reference to query DTO

class UserCreate(BaseModel):
    """DTO for creating a user."""
    username: str
    email: EmailStr
    full_name: str
    password: str

class UserGet(BaseEntityGet):
    """DTO for getting a single user."""
    id: str
    username: str
    email: EmailStr
    full_name: str
    is_active: bool
    # Inherits: created_at, updated_at, created_by, updated_by

class UserList(BaseEntityList):
    """DTO for listing users."""
    id: str
    username: str
    email: EmailStr
    full_name: str
    # Inherits: created_at, updated_at

class UserUpdate(BaseModel):
    """DTO for updating a user."""
    email: Optional[EmailStr] = None
    full_name: Optional[str] = None
    is_active: Optional[bool] = None

class UserQuery(BaseModel):
    """DTO for querying users."""
    username: Optional[str] = None
    email: Optional[str] = None
    is_active: Optional[bool] = None
    skip: int = 0
    limit: int = 100
```

## DTO Types

### 1. Create DTO

Used for creating new entities via POST requests.

**Characteristics**:
- Contains only required fields for creation
- No `id` (generated by backend)
- No audit fields (generated by backend)
- Validation rules via Pydantic

```python
class CourseCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    course_family_id: str
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
```

### 2. Get DTO

Used for returning single entity details via GET requests.

**Characteristics**:
- Extends `BaseEntityGet`
- Contains all fields (or most fields)
- Includes `id` and audit fields
- May include nested relationships

```python
class CourseGet(BaseEntityGet):
    id: str
    name: str
    description: Optional[str]
    course_family_id: str
    start_date: Optional[datetime]
    end_date: Optional[datetime]

    # Nested relationships (optional)
    course_family: Optional[CourseFamilyList] = None
    member_count: Optional[int] = None

    # Inherited from BaseEntityGet:
    # created_at, updated_at, created_by, updated_by
```

### 3. List DTO

Used for returning multiple entities via LIST requests.

**Characteristics**:
- Extends `BaseEntityList`
- Contains only essential fields (lighter than Get)
- Optimized for performance (fewer joins)
- No nested relationships (usually)

```python
class CourseList(BaseEntityList):
    id: str
    name: str
    course_family_id: str
    start_date: Optional[datetime]
    # Minimal fields for performance

    # Inherited from BaseEntityList:
    # created_at, updated_at
```

### 4. Update DTO

Used for updating entities via PUT/PATCH requests.

**Characteristics**:
- All fields are `Optional`
- Only provided fields are updated
- No `id` (in URL path)
- No audit fields (updated by backend)

```python
class CourseUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
```

### 5. Query DTO

Used for filtering/searching entities via query parameters.

**Characteristics**:
- All fields are `Optional`
- Includes pagination (`skip`, `limit`)
- Supports filtering by various fields

```python
class CourseQuery(BaseModel):
    name: Optional[str] = None
    course_family_id: Optional[str] = None
    is_active: Optional[bool] = None
    skip: int = 0
    limit: int = 100
```

## Base Classes

### BaseEntityList

Minimal audit fields for list responses:

```python
class BaseEntityList(BaseModel):
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    model_config = ConfigDict(arbitrary_types_allowed=True)
```

### BaseEntityGet

Full audit fields for detailed responses:

```python
class BaseEntityGet(BaseEntityList):
    created_by: Optional[str] = None
    updated_by: Optional[str] = None
```

## Code Generation

### 1. Python HTTP Client

The `computor-client` package is auto-generated from EntityInterface definitions.

**Generated Client**:

```python
# Auto-generated: computor-client/src/computor_client/endpoints/users.py
from computor_client.base_endpoint import BaseEndpointClient
from computor_types.users import UserCreate, UserGet, UserList, UserUpdate, UserQuery

class UsersEndpoint(BaseEndpointClient[UserCreate, UserGet, UserList, UserUpdate, UserQuery]):
    """Auto-generated client for Users endpoint."""

    def __init__(self, client):
        super().__init__(
            client=client,
            endpoint="/users",
            create_model=UserCreate,
            get_model=UserGet,
            list_model=UserList,
            update_model=UserUpdate,
            query_model=UserQuery,
        )
```

**Usage**:

```python
from computor_client import ComputorClient

async with ComputorClient("http://localhost:8000") as client:
    await client.authenticate("admin", "password")

    # Create
    user = await client.users.create(UserCreate(
        username="john",
        email="john@example.com",
        full_name="John Doe",
        password="secret",
    ))

    # Get
    user = await client.users.get("user-id")

    # List
    users = await client.users.list(UserQuery(is_active=True))

    # Update
    user = await client.users.update("user-id", UserUpdate(full_name="Jane Doe"))
```

### 2. TypeScript Interfaces

TypeScript interfaces are generated from Pydantic models:

```bash
bash generate_types.sh
# or
computor generate-types
```

**Generated TypeScript**:

```typescript
// frontend/src/types/users.ts
export interface UserCreate {
  username: string;
  email: string;
  full_name: string;
  password: string;
}

export interface UserGet {
  id: string;
  username: string;
  email: string;
  full_name: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  created_by?: string;
  updated_by?: string;
}

export interface UserList {
  id: string;
  username: string;
  email: string;
  full_name: string;
  created_at: string;
  updated_at: string;
}

export interface UserUpdate {
  email?: string;
  full_name?: string;
  is_active?: boolean;
}

export interface UserQuery {
  username?: string;
  email?: string;
  is_active?: boolean;
  skip?: number;
  limit?: number;
}
```

### 3. TypeScript HTTP Client

TypeScript client is also auto-generated:

```bash
bash generate_clients.sh
# or
computor generate-clients
```

**Generated Client**:

```typescript
// generated/typescript-client/users.ts
import { UserCreate, UserGet, UserList, UserUpdate, UserQuery } from '../types/users';

export class UsersClient {
  constructor(private baseURL: string, private getToken: () => string) {}

  async create(data: UserCreate): Promise<UserGet> {
    const response = await fetch(`${this.baseURL}/users`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getToken()}`,
      },
      body: JSON.stringify(data),
    });
    return response.json();
  }

  async get(id: string): Promise<UserGet> {
    const response = await fetch(`${this.baseURL}/users/${id}`, {
      headers: { 'Authorization': `Bearer ${this.getToken()}` },
    });
    return response.json();
  }

  async list(query?: UserQuery): Promise<UserList[]> {
    const params = new URLSearchParams(query as any);
    const response = await fetch(`${this.baseURL}/users?${params}`, {
      headers: { 'Authorization': `Bearer ${this.getToken()}` },
    });
    return response.json();
  }

  async update(id: string, data: UserUpdate): Promise<UserGet> {
    const response = await fetch(`${this.baseURL}/users/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getToken()}`,
      },
      body: JSON.stringify(data),
    });
    return response.json();
  }
}
```

## Backend Integration

### BackendEntityInterface

In the backend, EntityInterface is extended with backend-specific concerns:

```python
# computor-backend/src/computor_backend/interfaces/base.py
from computor_types.base import EntityInterface

class BackendEntityInterface(EntityInterface):
    """Backend extension of EntityInterface."""
    model = None          # SQLAlchemy model
    endpoint = None       # API endpoint path
    cacheable = False     # Redis caching enabled
    searchable = False    # Full-text search enabled
```

**Example**:

```python
# computor-backend/src/computor_backend/interfaces/users.py
from computor_types.users import UserInterface
from computor_backend.interfaces.base import BackendEntityInterface
from computor_backend.model.auth import User

class UserBackendInterface(UserInterface, BackendEntityInterface):
    """Backend user interface."""
    model = User
    endpoint = "/users"
    cacheable = True
    searchable = True
```

### Auto-Generated CRUD Endpoints

The backend can auto-generate CRUD endpoints from EntityInterface:

```python
# computor-backend/src/computor_backend/api/api_builder.py
from computor_backend.interfaces.users import UserBackendInterface

# Auto-generate CRUD router
user_router = CrudRouter(UserBackendInterface)

# Resulting endpoints:
# POST   /users          - create
# GET    /users/{id}     - get
# GET    /users          - list
# PUT    /users/{id}     - update
# DELETE /users/{id}     - delete
```

## Advanced Patterns

### Nested DTOs

Include related entities in responses:

```python
class CourseGet(BaseEntityGet):
    id: str
    name: str
    course_family_id: str

    # Nested relationship
    course_family: Optional[CourseFamilyList] = None
    members: Optional[List[CourseMemberList]] = None
```

### Computed Fields

Add computed fields using Pydantic validators:

```python
from pydantic import computed_field

class CourseGet(BaseEntityGet):
    id: str
    name: str
    start_date: datetime
    end_date: datetime

    @computed_field
    @property
    def duration_days(self) -> int:
        """Compute course duration in days."""
        return (self.end_date - self.start_date).days
```

### Custom Actions

Add custom action DTOs beyond CRUD:

```python
class CourseInterface(EntityInterface):
    create = "CourseCreate"
    get = "CourseGet"
    list = "CourseList"
    update = "CourseUpdate"
    query = "CourseQuery"

    # Custom actions
    enroll = "CourseEnrollRequest"
    bulk_import = "CourseBulkImportRequest"

class CourseEnrollRequest(BaseModel):
    student_id: str
    role: str = "_student"

class CourseBulkImportRequest(BaseModel):
    csv_file: str  # Base64 encoded CSV
```

### Validation Rules

Use Pydantic validators for complex validation:

```python
from pydantic import field_validator, model_validator

class CourseCreate(BaseModel):
    name: str
    start_date: datetime
    end_date: datetime

    @field_validator('name')
    @classmethod
    def validate_name(cls, v):
        if len(v) < 3:
            raise ValueError('Name must be at least 3 characters')
        return v

    @model_validator(mode='after')
    def validate_dates(self):
        if self.end_date <= self.start_date:
            raise ValueError('End date must be after start date')
        return self
```

## Discovery and Registration

### get_all_dtos()

The `get_all_dtos()` function discovers all EntityInterface subclasses:

```python
# computor-types/src/computor_types/__init__.py
def get_all_dtos():
    """Get all EntityInterface subclasses."""
    import pkgutil
    import inspect
    import computor_types

    interfaces = []

    for module_info in pkgutil.walk_packages(
        computor_types.__path__,
        computor_types.__name__ + "."
    ):
        module = __import__(module_info.name, fromlist=["__name__"])

        for name, obj in inspect.getmembers(module, inspect.isclass):
            if (issubclass(obj, EntityInterface) and
                obj is not EntityInterface and
                name.endswith('Interface')):
                interfaces.append(obj)

    return interfaces
```

**Usage in Backend**:

```python
from computor_types import get_all_dtos

# Register all entities at startup
for interface in get_all_dtos():
    register_entity(interface)
```

## Best Practices

### 1. Naming Conventions

- Interface class: `{Entity}Interface`
- Create DTO: `{Entity}Create`
- Get DTO: `{Entity}Get`
- List DTO: `{Entity}List`
- Update DTO: `{Entity}Update`
- Query DTO: `{Entity}Query`

### 2. Field Consistency

Use consistent field names across DTOs:

```python
# ✅ Good: Consistent field names
class UserCreate(BaseModel):
    email: EmailStr

class UserGet(BaseEntityGet):
    email: EmailStr

class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None

# ❌ Bad: Inconsistent field names
class UserCreate(BaseModel):
    email_address: EmailStr

class UserGet(BaseEntityGet):
    email: EmailStr  # Different name!
```

### 3. Keep DTOs Simple

DTOs should be data containers, not business logic:

```python
# ✅ Good: Simple DTO
class CourseCreate(BaseModel):
    name: str
    start_date: datetime

# ❌ Bad: Business logic in DTO
class CourseCreate(BaseModel):
    name: str
    start_date: datetime

    def is_valid(self):  # Don't do this!
        return self.start_date > datetime.now()
```

### 4. Use Base Classes

Always extend `BaseEntityGet` and `BaseEntityList`:

```python
# ✅ Good: Use base classes
class UserGet(BaseEntityGet):
    id: str
    username: str
    # Inherits audit fields

# ❌ Bad: Manually define audit fields
class UserGet(BaseModel):
    id: str
    username: str
    created_at: datetime  # Should inherit
    updated_at: datetime  # Should inherit
```

### 5. Separate Concerns

Keep `computor-types` pure (no backend dependencies):

```python
# ✅ Good: Pure Pydantic
from pydantic import BaseModel

class UserCreate(BaseModel):
    username: str

# ❌ Bad: Backend dependency
from sqlalchemy import Column  # Don't import in types!

class UserCreate(BaseModel):
    username: str
```

## Next Steps

- Learn about [Permission System](06-permission-system.md)
- Explore [API Development](10-api-development.md)
- Review [Type Generation](13-type-generation.md)

---

**Previous**: [← Backend Architecture](04-backend-architecture.md) | **Next**: [Permission System →](06-permission-system.md)
